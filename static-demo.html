<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymarket $POLY Airdrop Estimator</title>
    <link rel="icon" type="image/png" href="polydrop_logo.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
    </style>
</head>
<body class="gradient-bg min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <div class="text-center mb-10">
            <h1 class="text-5xl font-bold text-white mb-4">
                Polymarket $POLY Airdrop Estimator
            </h1>
            <p class="text-xl text-gray-200">
                Check multiple wallet addresses for airdrop eligibility
            </p>
        </div>

        <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 shadow-2xl max-w-4xl mx-auto">
            <div class="mb-4">
                <label class="block text-white text-lg font-semibold mb-2">
                    Enter Wallet Addresses
                </label>
                <p class="text-gray-300 text-sm mb-4">
                    Enter one or more addresses (separate with commas or new lines)
                </p>
                <textarea
                    id="addresses"
                    placeholder="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb7
0x5aAeb6053f3E94C9b9A09f33669435E7Ef1BeAed
0x..."
                    class="w-full h-32 px-4 py-3 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-blue-400"
                ></textarea>
            </div>

            <button
                onclick="analyzeWallets()"
                class="w-full py-3 px-6 bg-gradient-to-r from-blue-500 to-purple-600 text-white font-semibold rounded-lg hover:from-blue-600 hover:to-purple-700 transition-all duration-200"
            >
                Check
            </button>

            <div class="mt-6 p-4 bg-blue-500/10 border border-blue-400/30 rounded-lg">
                <p class="text-blue-200 text-sm">
                    <span class="font-semibold">Start Trading:</span> Haven't started on Polymarket yet?
                    <a href="https://polymarket.com/" target="_blank" class="text-blue-300 underline hover:text-blue-100">
                        Join Polymarket now
                    </a> to build your trading history and qualify for the upcoming $POLY airdrop!
                </p>
            </div>
        </div>

        <div id="results" class="mt-8 hidden">
            <!-- Results will be inserted here -->
        </div>
    </div>

    <script>
        async function analyzeWallets() {
            const addressInput = document.getElementById('addresses').value;
            const addresses = addressInput.split(/[\n,]+/)
                .map(addr => addr.trim())
                .filter(addr => addr.length > 0);

            if (addresses.length === 0) {
                alert('Please enter at least one address');
                return;
            }

            // Show loading state
            const resultsDiv = document.getElementById('results');
            resultsDiv.classList.remove('hidden');
            resultsDiv.innerHTML = '<div class="text-center text-white text-xl">Loading real data from Polymarket...</div>';

            // Send stats to backend (non-blocking)
            fetch('https://polydrop.fun/api/stats', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ addressCount: addresses.length })
            }).catch(() => {}); // Silently fail

            // Fetch real data from Polymarket for each address
            const results = await Promise.all(
                addresses.map(address => fetchRealData(address))
            );

            displayResults(results);
        }

        async function fetchRealData(address) {
            try {
                // Fetch user activity from Polymarket
                const trades = await fetchUserActivity(address);
                const metrics = calculateMetrics(trades);
                const airdropEstimate = estimateAirdrop(metrics);

                return {
                    address: address,
                    tier: airdropEstimate.estimatedTier,
                    volume: metrics.totalVolume,
                    pnl: metrics.pnl,
                    activeDays: metrics.activeDays,
                    marketsTraded: metrics.uniqueMarkets,
                    percentile: airdropEstimate.percentile,
                    estimatedMin: airdropEstimate.estimatedAllocation.min,
                    estimatedMax: airdropEstimate.estimatedAllocation.max,
                    suggestions: generateSuggestions(metrics)
                };
            } catch (error) {
                console.error('Error fetching data for', address, error);
                return {
                    address: address,
                    tier: 'None',
                    volume: 0,
                    pnl: 0,
                    activeDays: 0,
                    marketsTraded: 0,
                    percentile: 0,
                    estimatedMin: 0,
                    estimatedMax: 0,
                    suggestions: ['Unable to fetch data - please check wallet address']
                };
            }
        }

        async function fetchUserActivity(walletAddress) {
            const allTrades = [];
            let offset = 0;
            const limit = 500;
            const maxTrades = 2000; // จำกัด 2,000 trades เพื่อความเร็ว

            // ดึงข้อมูลล่าสุด 2,000 trades
            while (allTrades.length < maxTrades) {
                try {
                    const url = `https://data-api.polymarket.com/activity?user=${walletAddress}&limit=${limit}&offset=${offset}&type=TRADE&sortBy=TIMESTAMP&sortDirection=DESC`;

                    const response = await fetch(url, {
                        headers: { 'Accept': 'application/json' },
                        signal: AbortSignal.timeout(30000)
                    });

                    if (!response.ok) {
                        if (response.status === 404) break;
                        throw new Error(`API responded with status: ${response.status}`);
                    }

                    const data = await response.json();
                    if (!Array.isArray(data) || data.length === 0) break;

                    allTrades.push(...data);

                    // Update progress
                    const resultsDiv = document.getElementById('results');
                    const percentage = Math.round((allTrades.length / maxTrades) * 100);
                    resultsDiv.innerHTML = `<div class="text-center text-white text-xl">
                        <div class="mb-2">Analyzing trading history...</div>
                        <div class="text-lg">${allTrades.length} trades loaded</div>
                        <div class="w-full max-w-md mx-auto bg-gray-700 rounded-full h-2 mt-4">
                            <div class="bg-gradient-to-r from-blue-400 to-purple-400 h-2 rounded-full transition-all" style="width: ${percentage}%"></div>
                        </div>
                    </div>`;

                    if (data.length < limit) break;

                    offset += limit;
                } catch (error) {
                    console.error(`Error fetching trades at offset ${offset}:`, error);
                    if (allTrades.length > 0) break;
                    throw error;
                }
            }

            return allTrades;
        }

        function calculateMetrics(trades) {
            if (!trades || trades.length === 0) {
                return {
                    totalVolume: 0,
                    pnl: 0,
                    activeDays: 0,
                    uniqueMarkets: 0,
                    totalTrades: 0,
                    closedPositions: 0,
                    consistency: 0
                };
            }

            let totalVolume = 0;
            const activeDaysSet = new Set();
            const uniqueMarketsSet = new Set();
            const positions = {};

            trades.forEach(trade => {
                const tradeVolume = trade.usdcSize || (trade.size * trade.price);
                totalVolume += tradeVolume;

                const date = new Date(trade.timestamp * 1000).toISOString().split('T')[0];
                activeDaysSet.add(date);
                uniqueMarketsSet.add(trade.conditionId);

                const positionKey = `${trade.conditionId}-${trade.outcomeIndex}`;
                if (!positions[positionKey]) {
                    positions[positionKey] = { buys: [], sells: [] };
                }

                if (trade.side === 'BUY') {
                    positions[positionKey].buys.push(trade);
                } else {
                    positions[positionKey].sells.push(trade);
                }
            });

            // Calculate PNL using FIFO (รวมทั้ง realized และ unrealized)
            let totalPnl = 0;
            let realizedPnl = 0;
            let unrealizedPnl = 0;
            let closedPositions = 0;

            for (const positionKey in positions) {
                const { buys, sells } = positions[positionKey];
                buys.sort((a, b) => a.timestamp - b.timestamp);
                sells.sort((a, b) => a.timestamp - b.timestamp);

                let buyIndex = 0;
                let remainingBuySize = buys[buyIndex]?.size || 0;
                let positionPnl = 0;

                // Calculate realized PNL from matched trades
                for (const sell of sells) {
                    let remainingSellSize = sell.size;

                    while (remainingSellSize > 0 && buyIndex < buys.length) {
                        const buy = buys[buyIndex];

                        if (remainingBuySize === 0) {
                            buyIndex++;
                            if (buyIndex < buys.length) {
                                remainingBuySize = buys[buyIndex].size;
                            }
                            continue;
                        }

                        const matchedSize = Math.min(remainingSellSize, remainingBuySize);
                        const profit = (sell.price - buy.price) * matchedSize;

                        positionPnl += profit;
                        realizedPnl += profit;
                        remainingSellSize -= matchedSize;
                        remainingBuySize -= matchedSize;
                    }
                }

                // Calculate unrealized PNL for remaining open positions
                const totalBuySize = buys.reduce((sum, b) => sum + b.size, 0);
                const totalSellSize = sells.reduce((sum, s) => sum + s.size, 0);
                const openSize = totalBuySize - totalSellSize;

                if (openSize > 0.0001) {
                    // มี position ที่ยังเปิดอยู่ - ประมาณ unrealized PNL
                    // ใช้ราคาล่าสุดเป็นราคา mark-to-market (ราคา sell ล่าสุด)
                    const lastPrice = sells.length > 0 ? sells[sells.length - 1].price :
                                     buys.length > 0 ? buys[buys.length - 1].price : 0;

                    // คำนวณ weighted average buy price สำหรับ position ที่เหลือ
                    let totalCost = 0;
                    let totalSize = 0;
                    let tempBuyIndex = buyIndex;
                    let tempRemaining = remainingBuySize;

                    while (totalSize < openSize && tempBuyIndex < buys.length) {
                        const buy = buys[tempBuyIndex];
                        if (tempRemaining === 0) {
                            tempBuyIndex++;
                            if (tempBuyIndex < buys.length) {
                                tempRemaining = buys[tempBuyIndex].size;
                            }
                            continue;
                        }

                        const sizeToAdd = Math.min(openSize - totalSize, tempRemaining);
                        totalCost += buy.price * sizeToAdd;
                        totalSize += sizeToAdd;
                        tempRemaining -= sizeToAdd;
                    }

                    const avgBuyPrice = totalSize > 0 ? totalCost / totalSize : 0;
                    const unrealizedForPosition = (lastPrice - avgBuyPrice) * openSize;
                    unrealizedPnl += unrealizedForPosition;
                    positionPnl += unrealizedForPosition;
                } else if (Math.abs(openSize) < 0.0001) {
                    closedPositions++;
                }

                totalPnl += positionPnl;
            }

            const activeDays = activeDaysSet.size;
            const timestamps = trades.map(t => t.timestamp).sort((a, b) => a - b);
            const firstTrade = timestamps[0];
            const lastTrade = timestamps[timestamps.length - 1];
            const totalDays = Math.max(1, Math.ceil((lastTrade - firstTrade) / 86400));
            const consistency = activeDays / totalDays;

            return {
                totalVolume: Math.round(totalVolume * 100) / 100,
                pnl: Math.round(totalPnl * 100) / 100,
                activeDays,
                uniqueMarkets: uniqueMarketsSet.size,
                totalTrades: trades.length,
                closedPositions,
                consistency: Math.round(consistency * 100) / 100
            };
        }

        function estimateAirdrop(metrics) {
            const { totalVolume, pnl, activeDays, uniqueMarkets, totalTrades, closedPositions, consistency } = metrics;

            let tier = 'None';
            let percentile = 0;
            let minAllocation = 0;
            let maxAllocation = 0;

            const volumeScore = Math.min(totalVolume / 100000, 1) * 40;
            const consistencyScore = consistency * 30;
            const diversityScore = Math.min(uniqueMarkets / 50, 1) * 15;
            const activityScore = Math.min(totalTrades / 200, 1) * 10;
            const pnlScore = pnl > 0 ? Math.min(pnl / 10000, 1) * 5 : 0;

            const totalScore = volumeScore + consistencyScore + diversityScore + activityScore + pnlScore;

            if (totalScore >= 70 && totalVolume >= 50000) {
                tier = 'S';
                percentile = Math.min(99, 90 + totalScore / 10);
                minAllocation = 5000;
                maxAllocation = 20000;
            } else if (totalScore >= 50 && totalVolume >= 10000) {
                tier = 'A';
                percentile = Math.min(95, 75 + totalScore / 4);
                minAllocation = 1000;
                maxAllocation = 5000;
            } else if (totalScore >= 30 && totalVolume >= 1000) {
                tier = 'B';
                percentile = Math.min(85, 50 + totalScore / 2);
                minAllocation = 500;
                maxAllocation = 2000;
            } else if (totalVolume >= 100) {
                tier = 'C';
                percentile = Math.min(70, 20 + totalScore);
                minAllocation = 100;
                maxAllocation = 500;
            } else {
                percentile = Math.min(50, totalScore);
                minAllocation = 0;
                maxAllocation = 100;
            }

            if (pnl >= 1000 && tier !== 'None') {
                percentile = Math.min(99.5, percentile + 3);
                minAllocation = Math.round(minAllocation * 1.3);
                maxAllocation = Math.round(maxAllocation * 1.3);
            }

            if (consistency < 0.2 && activeDays < 30) {
                percentile = Math.max(0, percentile - 15);
                minAllocation = Math.round(minAllocation * 0.7);
                maxAllocation = Math.round(maxAllocation * 0.7);
            }

            return {
                estimatedTier: tier,
                percentile: Math.round(percentile),
                estimatedAllocation: {
                    min: Math.round(minAllocation),
                    max: Math.round(maxAllocation)
                }
            };
        }

        function generateSuggestions(metrics) {
            const suggestions = [];

            if (metrics.totalVolume < 1000) {
                suggestions.push(`Increase trading volume to at least $1,000 (currently $${Math.round(metrics.totalVolume)})`);
            }

            if (metrics.activeDays < 30) {
                suggestions.push(`Trade for ${30 - metrics.activeDays} more days to improve consistency`);
            }

            if (metrics.uniqueMarkets < 10) {
                suggestions.push(`Trade in ${10 - metrics.uniqueMarkets} more markets to diversify`);
            }

            if (metrics.closedPositions < 5) {
                suggestions.push('Close more positions to demonstrate complete trading cycles');
            }

            if (metrics.consistency < 0.3) {
                suggestions.push('Increase trading frequency - aim for at least 3 days per week');
            }

            if (suggestions.length === 0) {
                suggestions.push('Great job! Keep maintaining your current trading patterns.');
            }

            return suggestions;
        }

        function displayResults(wallets) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.classList.remove('hidden');

            const html = `
                <h2 class="text-3xl font-bold text-white text-center mb-6">Analysis Results</h2>

                <div class="grid gap-6 md:grid-cols-2 lg:grid-cols-3 max-w-7xl mx-auto">
                    ${wallets.map(wallet => `
                        <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-6 shadow-xl border border-white/20">
                            <div class="mb-4">
                                <p class="text-gray-300 text-sm">Address</p>
                                <p class="text-white font-mono text-sm">${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}</p>
                            </div>

                            <div class="mb-4">
                                <span class="inline-block px-4 py-2 rounded-full text-white font-bold bg-gradient-to-r ${
                                    wallet.tier === 'S' ? 'from-yellow-400 to-orange-500' :
                                    wallet.tier === 'A' ? 'from-purple-500 to-pink-500' :
                                    wallet.tier === 'B' ? 'from-blue-500 to-cyan-500' :
                                    'from-green-500 to-teal-500'
                                }">
                                    Tier ${wallet.tier}
                                </span>
                            </div>

                            <div class="grid grid-cols-2 gap-4 mb-4">
                                <div>
                                    <p class="text-gray-400 text-xs">Volume</p>
                                    <p class="text-white font-semibold">$${wallet.volume.toLocaleString()}</p>
                                </div>
                                <div>
                                    <p class="text-gray-400 text-xs">PNL</p>
                                    <p class="${wallet.pnl >= 0 ? 'text-green-400' : 'text-red-400'} font-semibold">
                                        ${wallet.pnl >= 0 ? '+' : ''}$${wallet.pnl.toLocaleString()}
                                    </p>
                                </div>
                                <div>
                                    <p class="text-gray-400 text-xs">Active Days</p>
                                    <p class="text-white font-semibold">${wallet.activeDays}</p>
                                </div>
                                <div>
                                    <p class="text-gray-400 text-xs">Markets</p>
                                    <p class="text-white font-semibold">${wallet.marketsTraded}</p>
                                </div>
                            </div>

                            <div class="mb-4 p-3 bg-white/5 rounded-lg">
                                <p class="text-gray-300 text-sm mb-1">Percentile Rank</p>
                                <div class="flex items-center">
                                    <div class="flex-1 bg-gray-700 rounded-full h-2 mr-2">
                                        <div class="bg-gradient-to-r from-blue-400 to-purple-400 h-2 rounded-full"
                                             style="width: ${wallet.percentile}%"></div>
                                    </div>
                                    <span class="text-white font-semibold">${wallet.percentile}%</span>
                                </div>
                            </div>

                            <div class="mb-4 p-3 bg-purple-500/10 border border-purple-400/30 rounded-lg">
                                <p class="text-purple-300 text-sm mb-1">Estimated $POLY</p>
                                <p class="text-white font-bold text-lg">
                                    ${wallet.estimatedMin.toLocaleString()} - ${wallet.estimatedMax.toLocaleString()}
                                </p>
                            </div>
                        </div>
                    `).join('')}
                </div>

                <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-6 mt-8 max-w-5xl mx-auto">
                    <h3 class="text-xl font-bold text-white mb-4">Comparison Table</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-white">
                            <thead>
                                <tr class="border-b border-white/20">
                                    <th class="text-left py-2 px-4">Address</th>
                                    <th class="text-right py-2 px-4">Volume</th>
                                    <th class="text-right py-2 px-4">PNL</th>
                                    <th class="text-right py-2 px-4">Tier</th>
                                    <th class="text-right py-2 px-4">Est. $POLY</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${wallets.map(wallet => `
                                    <tr class="border-b border-white/10">
                                        <td class="py-2 px-4 font-mono text-sm">${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}</td>
                                        <td class="text-right py-2 px-4">$${wallet.volume.toLocaleString()}</td>
                                        <td class="text-right py-2 px-4 ${wallet.pnl >= 0 ? 'text-green-400' : 'text-red-400'}">
                                            ${wallet.pnl >= 0 ? '+' : ''}$${wallet.pnl.toLocaleString()}
                                        </td>
                                        <td class="text-right py-2 px-4">${wallet.tier}</td>
                                        <td class="text-right py-2 px-4">${wallet.estimatedMin}-${wallet.estimatedMax}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="bg-gradient-to-r from-purple-600/20 to-blue-600/20 backdrop-blur-lg rounded-2xl p-6 mt-8 max-w-5xl mx-auto border border-purple-400/30">
                    <div class="text-center">
                        <h3 class="text-2xl font-bold text-white mb-3">Ready to Maximize Your Airdrop?</h3>
                        <p class="text-gray-200 mb-4">
                            Join thousands of traders on Polymarket earning rewards while predicting real-world events
                        </p>
                        <a href="https://polymarket.com/" target="_blank"
                           class="inline-block px-8 py-3 bg-gradient-to-r from-purple-500 to-blue-500 text-white font-semibold rounded-lg hover:from-purple-600 hover:to-blue-600 transition-all duration-200 transform hover:scale-105">
                            Start Trading on Polymarket →
                        </a>
                        <p class="text-gray-300 text-sm mt-4">
                            Higher volume + consistent activity = Better airdrop tier
                        </p>
                    </div>
                </div>
            `;

            resultsDiv.innerHTML = html;
        }
    </script>
</body>
</html>